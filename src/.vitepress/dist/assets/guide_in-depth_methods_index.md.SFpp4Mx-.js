import{_ as e,c as t,o,U as a}from"./chunks/framework.on6qGByC.js";const _=JSON.parse('{"title":"Methods","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"guide/in-depth/methods/index.md","filePath":"guide/in-depth/methods/index.md"}'),i={name:"guide/in-depth/methods/index.md"},n=a('<h1 id="methods" tabindex="-1">Methods <a class="header-anchor" href="#methods" aria-label="Permalink to &quot;Methods&quot;">â€‹</a></h1><p>When the declarative model based on the template is not enough, you can complement it with imperative code based on Javascript functions. The Graphane component can include functions for complex algorithm, data manipulation or event handling.</p><p>You can load the method with several methods:</p><ul><li>with <code>&lt;script type=&quot;methods&quot;&gt;&lt;/script&gt;</code> with the <a href="./embebed.html">code embebed</a>.</li><li>with the <code>methods-src</code> for <a href="./external.html">load a resource</a> with the Javascript functions.</li></ul><p>In Graphane, the methods defined are accesibles from the template directives, and also be called from the property <a href="./property.html"><code>.methods</code></a>.</p><p>The method definition is sandboxed and has limited access to other functions or libraries. This restricted access ensures a secure and predictable environment for evaluating functions within the component.</p>',6),d=[n];function s(h,r,c,l,p,m){return o(),t("div",null,d)}const f=e(i,[["render",s]]);export{_ as __pageData,f as default};
